{
  "master": {
    "tasks": [
      {
        "id": 46,
        "title": "Remove default admin key and implement proper environment validation",
        "description": "Replace the default admin key with proper environment variable validation to prevent unauthenticated access to admin endpoints.",
        "details": "1. Modify `src/routes/admin.routes.ts` to remove the default admin key fallback\n2. Implement proper environment variable validation at startup\n3. Add clear error handling for missing environment variables\n4. Update documentation to clarify required environment variables\n\nPseudo-code implementation:\n```typescript\n// In src/routes/admin.routes.ts\nconst ADMIN_KEY = process.env.ADMIN_KEY;\nif (!ADMIN_KEY) {\n  throw new Error('ADMIN_KEY environment variable is required');\n}\n\n// In application startup (src/index.ts or similar)\nfunction validateRequiredEnvVars() {\n  const required = ['ADMIN_KEY', 'DB_USERNAME', 'DB_PASSWORD'];\n  const missing = required.filter(key => !process.env[key]);\n  \n  if (missing.length > 0) {\n    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);\n  }\n}\n```",
        "testStrategy": "1. Unit test the environment validation function with various scenarios (all variables present, some missing)\n2. Integration test to verify application fails to start when ADMIN_KEY is missing\n3. Test admin routes with valid and invalid keys to ensure proper authentication\n4. Verify error messages are clear and actionable",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Enable SSL certificate validation for database connections",
        "description": "Fix the critical security vulnerability by enabling proper SSL certificate validation for database connections to prevent man-in-the-middle attacks.",
        "details": "1. Update the database configuration in `src/config/database.config.ts` to properly handle SSL connections\n2. Remove the `rejectUnauthorized: false` setting which disables certificate validation\n3. Implement proper CA certificate handling for production environments\n4. Add environment variable for specifying CA certificate path\n\nPseudo-code implementation:\n```typescript\n// In src/config/database.config.ts\nconst sslConfig = process.env.DB_SSL === 'true' \n  ? process.env.NODE_ENV === 'production'\n    ? { \n        rejectUnauthorized: true,\n        ca: process.env.DB_CA_CERT ? fs.readFileSync(process.env.DB_CA_CERT) : undefined \n      }\n    : { rejectUnauthorized: true }\n  : false;\n\n// In database config object\nssl: sslConfig,\n```",
        "testStrategy": "1. Unit test SSL configuration generation with different environment variables\n2. Integration test with a mock SSL server to verify certificate validation\n3. Test connection with valid and invalid certificates\n4. Document and test deployment process with proper certificates",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Implement authentication middleware for all API endpoints",
        "description": "Add authentication middleware to all public API endpoints as required by the project specifications, ensuring all routes are properly secured.",
        "details": "1. Create a new authentication middleware in `src/middleware/auth.middleware.ts`\n2. Implement API key or JWT validation based on project requirements\n3. Apply the middleware to all non-health check routes\n4. Update Swagger documentation to reflect authentication requirements\n\nPseudo-code implementation:\n```typescript\n// src/middleware/auth.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { logger } from '../utils/logger';\n\nexport function authMiddleware(req: Request, res: Response, next: NextFunction) {\n  const apiKey = req.headers['x-api-key'] || req.query.apiKey;\n  \n  if (!apiKey) {\n    return res.status(401).json({ \n      error: { \n        message: 'Authentication required', \n        statusCode: 401,\n        timestamp: new Date().toISOString() \n      } \n    });\n  }\n  \n  // Validate API key (from database or environment variable)\n  if (apiKey !== process.env.API_KEY) {\n    logger.warn(`Invalid API key attempt: ${req.ip}`);\n    return res.status(403).json({ \n      error: { \n        message: 'Invalid authentication credentials', \n        statusCode: 403,\n        timestamp: new Date().toISOString() \n      } \n    });\n  }\n  \n  next();\n}\n\n// Apply to routes in src/app.ts\napp.use('/api/v1/readings', authMiddleware, readingsRouter);\napp.use('/api/v1/traditions', authMiddleware, traditionsRouter);\napp.use('/api/v1/calendar', authMiddleware, calendarRouter);\n```",
        "testStrategy": "1. Unit test the auth middleware with various scenarios (missing key, invalid key, valid key)\n2. Integration tests for each protected endpoint to verify authentication\n3. Test bypass of health check endpoints\n4. Performance test to ensure minimal overhead\n5. Test error response format consistency",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Replace shell command execution with programmatic alternatives",
        "description": "Replace the unsafe `execSync` calls in admin routes with programmatic alternatives or job queue implementation to prevent command injection vulnerabilities.",
        "details": "1. Install and configure a job queue library (Bull or Agenda)\n2. Create dedicated job processors for each current shell command\n3. Replace direct `execSync` calls with job queue operations\n4. Implement proper error handling and job status tracking\n\nPseudo-code implementation:\n```typescript\n// Install Bull: npm install bull @types/bull\n\n// src/jobs/queue.ts\nimport Queue from 'bull';\nimport { redisConfig } from '../config/redis.config';\n\nexport const migrationQueue = new Queue('database-migrations', {\n  redis: redisConfig\n});\n\nexport const importQueue = new Queue('data-imports', {\n  redis: redisConfig\n});\n\n// src/jobs/processors/migration.processor.ts\nimport { DataSource } from 'typeorm';\nimport { migrationQueue } from '../queue';\nimport { logger } from '../../utils/logger';\n\nmigrationQueue.process(async (job) => {\n  try {\n    const dataSource = await getDataSource();\n    const migrations = await dataSource.runMigrations();\n    return { success: true, migrations };\n  } catch (error) {\n    logger.error('Migration job failed:', error);\n    throw error;\n  }\n});\n\n// In admin routes\nrouter.post('/run-migrations', adminAuth, async (req, res) => {\n  try {\n    const job = await migrationQueue.add({}, { \n      attempts: 3,\n      backoff: { type: 'exponential', delay: 5000 }\n    });\n    \n    return res.json({ \n      success: true, \n      message: 'Migration job queued', \n      jobId: job.id \n    });\n  } catch (error) {\n    logger.error('Failed to queue migration job:', error);\n    return res.status(500).json({ error: 'Failed to queue migration job' });\n  }\n});\n```",
        "testStrategy": "1. Unit test job processors with mocked database connections\n2. Integration test job queue with test database\n3. Test error handling and retry logic\n4. Test job status reporting\n5. Load test with multiple concurrent jobs",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Create database schema sync migration",
        "description": "Create a comprehensive migration to align the database schema with TypeORM entities, fixing the critical issue of schema drift and missing columns.",
        "details": "1. Audit all entities against existing migrations to identify discrepancies\n2. Create a new migration that adds missing columns and fixes type mismatches\n3. Add validation to ensure entity-migration consistency\n4. Document the schema changes\n\nPseudo-code implementation:\n```typescript\n// src/migrations/1704456789-SchemaSync.ts\nimport { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class SchemaSync1704456789 implements MigrationInterface {\n  name = 'SchemaSync1704456789';\n\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Add missing tradition_id column to special_day table\n    await queryRunner.query(`\n      ALTER TABLE \"special_day\" ADD COLUMN IF NOT EXISTS \"tradition_id\" integer\n    `);\n    \n    // Add foreign key constraint\n    await queryRunner.query(`\n      ALTER TABLE \"special_day\" ADD CONSTRAINT \"FK_special_day_tradition\" \n      FOREIGN KEY (\"tradition_id\") REFERENCES \"tradition\"(\"id\") ON DELETE CASCADE\n    `);\n    \n    // Fix type mismatches\n    // Convert rank from integer/varchar to enum\n    await queryRunner.query(`\n      ALTER TABLE \"special_day\" \n      ALTER COLUMN \"rank\" TYPE text\n    `);\n    \n    // Convert reading_office from varchar to enum\n    await queryRunner.query(`\n      ALTER TABLE \"reading\" \n      ALTER COLUMN \"reading_office\" TYPE text\n    `);\n    \n    // Add missing indexes\n    await queryRunner.query(`\n      CREATE INDEX IF NOT EXISTS \"idx_reading_date_tradition_office\" \n      ON \"reading\" (\"date\", \"tradition_id\", \"reading_office\")\n    `);\n    \n    await queryRunner.query(`\n      CREATE INDEX IF NOT EXISTS \"idx_tradition_year\" \n      ON \"tradition\" (\"tradition_id\", \"year\")\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    // Remove indexes\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_tradition_year\"`);\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_reading_date_tradition_office\"`);\n    \n    // Remove foreign key\n    await queryRunner.query(`ALTER TABLE \"special_day\" DROP CONSTRAINT IF EXISTS \"FK_special_day_tradition\"`);\n    \n    // Remove column\n    await queryRunner.query(`ALTER TABLE \"special_day\" DROP COLUMN IF EXISTS \"tradition_id\"`);\n  }\n}\n```",
        "testStrategy": "1. Create test database and run migrations from scratch to verify schema creation\n2. Test with existing data to ensure compatibility\n3. Verify foreign key constraints work correctly\n4. Test rollback (down migration) functionality\n5. Create entity validation test to ensure entities match schema",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Move admin key to Authorization header with constant-time comparison",
        "description": "Improve security by moving the admin key from request body to Authorization header and implement constant-time comparison to prevent timing attacks.",
        "details": "1. Update admin routes to use Authorization header instead of request body\n2. Implement constant-time comparison for admin key validation\n3. Update error handling to not expose sensitive information\n4. Document the new authentication method\n\nPseudo-code implementation:\n```typescript\n// Install crypto-js: npm install crypto-js @types/crypto-js\n\n// src/middleware/admin-auth.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { timingSafeEqual } from 'crypto';\nimport { logger } from '../utils/logger';\n\nexport function adminAuthMiddleware(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ \n      error: { \n        message: 'Admin authentication required', \n        statusCode: 401,\n        timestamp: new Date().toISOString() \n      } \n    });\n  }\n  \n  const providedKey = authHeader.slice(7); // Remove 'Bearer ' prefix\n  const adminKey = process.env.ADMIN_KEY;\n  \n  if (!adminKey) {\n    logger.error('ADMIN_KEY environment variable not set');\n    return res.status(500).json({ \n      error: { \n        message: 'Server configuration error', \n        statusCode: 500,\n        timestamp: new Date().toISOString() \n      } \n    });\n  }\n  \n  // Constant-time comparison to prevent timing attacks\n  try {\n    const providedBuffer = Buffer.from(providedKey);\n    const actualBuffer = Buffer.from(adminKey);\n    \n    if (\n      providedBuffer.length !== actualBuffer.length ||\n      !timingSafeEqual(providedBuffer, actualBuffer)\n    ) {\n      logger.warn(`Invalid admin authentication attempt from ${req.ip}`);\n      return res.status(403).json({ \n        error: { \n          message: 'Invalid admin credentials', \n          statusCode: 403,\n          timestamp: new Date().toISOString() \n        } \n      });\n    }\n    \n    next();\n  } catch (error) {\n    logger.error('Error during admin authentication:', error);\n    return res.status(500).json({ \n      error: { \n        message: 'Authentication error', \n        statusCode: 500,\n        timestamp: new Date().toISOString() \n      } \n    });\n  }\n}\n\n// Update admin routes\nrouter.use(adminAuthMiddleware);\n```",
        "testStrategy": "1. Unit test the admin auth middleware with various scenarios\n2. Test with valid and invalid Authorization headers\n3. Test with missing Authorization header\n4. Verify timing-safe comparison works correctly\n5. Test error handling and response format",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implement dependency injection container",
        "description": "Implement a dependency injection container to reduce tight coupling, improve testability, and manage service lifecycles properly.",
        "details": "1. Install a DI container library (tsyringe, inversify, or awilix)\n2. Create interfaces for all services\n3. Register services with the container\n4. Update controllers to use injected dependencies\n5. Remove lazy controller initialization pattern\n\nPseudo-code implementation:\n```typescript\n// Install tsyringe: npm install tsyringe reflect-metadata\n\n// src/di/container.ts\nimport 'reflect-metadata';\nimport { container } from 'tsyringe';\nimport { ReadingsService } from '../services/readings.service';\nimport { TraditionsService } from '../services/traditions.service';\nimport { CalendarService } from '../services/calendar.service';\nimport { DatabaseService } from '../services/database.service';\n\n// Register services\ncontainer.register('DatabaseService', { useClass: DatabaseService });\ncontainer.register('ReadingsService', { useClass: ReadingsService });\ncontainer.register('TraditionsService', { useClass: TraditionsService });\ncontainer.register('CalendarService', { useClass: CalendarService });\n\nexport { container };\n\n// src/services/readings.service.ts\nimport { injectable, inject } from 'tsyringe';\n\n@injectable()\nexport class ReadingsService {\n  constructor(\n    @inject('DatabaseService') private databaseService: DatabaseService,\n    @inject('TraditionsService') private traditionsService: TraditionsService\n  ) {}\n  \n  // Service methods\n}\n\n// src/controllers/readings.controller.ts\nimport { injectable, inject } from 'tsyringe';\n\n@injectable()\nexport class ReadingsController {\n  constructor(\n    @inject('ReadingsService') private readingsService: ReadingsService\n  ) {}\n  \n  // Controller methods\n}\n\n// src/routes/readings.routes.ts\nimport { container } from '../di/container';\n\nconst router = express.Router();\nconst readingsController = container.resolve(ReadingsController);\n\nrouter.get('/today', (req, res) => readingsController.getToday(req, res));\n// Other routes\n```",
        "testStrategy": "1. Unit test the DI container setup\n2. Test service resolution and dependency injection\n3. Create mock implementations for testing\n4. Verify controllers receive correct dependencies\n5. Test application bootstrapping with DI",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Fix error handling to prevent silent failures",
        "description": "Improve error handling in services to prevent silent failures and ensure proper error propagation to clients.",
        "details": "1. Audit all catch blocks in services that return null, empty arrays, or swallow errors\n2. Implement proper error propagation\n3. Create custom error classes for different error types\n4. Standardize error response format across the application\n\nPseudo-code implementation:\n```typescript\n// src/errors/app-error.ts\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public code?: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message: string = 'Resource not found', details?: any) {\n    super(message, 404, 'NOT_FOUND', details);\n  }\n}\n\nexport class DatabaseError extends AppError {\n  constructor(message: string = 'Database error', details?: any) {\n    super(message, 500, 'DATABASE_ERROR', details);\n  }\n}\n\n// In services\nimport { DatabaseError, NotFoundError } from '../errors/app-error';\n\nexport class ReadingsService {\n  async getReadingsByDate(date: string): Promise<Reading[]> {\n    try {\n      const readings = await this.readingRepository.find({ where: { date } });\n      \n      if (!readings || readings.length === 0) {\n        throw new NotFoundError(`No readings found for date ${date}`);\n      }\n      \n      return readings;\n    } catch (error) {\n      if (error instanceof AppError) {\n        throw error; // Re-throw application errors\n      }\n      \n      logger.error(`Error fetching readings for date ${date}:`, error);\n      throw new DatabaseError('Failed to fetch readings', { date, originalError: error.message });\n    }\n  }\n}\n\n// In error handler middleware\nimport { AppError } from '../errors/app-error';\n\nexport function errorHandler(error: Error, req: Request, res: Response, next: NextFunction) {\n  if (error instanceof AppError) {\n    return res.status(error.statusCode).json({\n      error: {\n        message: error.message,\n        code: error.code,\n        statusCode: error.statusCode,\n        timestamp: new Date().toISOString(),\n        details: process.env.NODE_ENV === 'production' ? undefined : error.details\n      }\n    });\n  }\n  \n  // Default error handling\n  const statusCode = 500;\n  return res.status(statusCode).json({\n    error: {\n      message: 'Internal server error',\n      statusCode,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n```",
        "testStrategy": "1. Unit test custom error classes\n2. Test error propagation in services\n3. Test error handler middleware with different error types\n4. Verify consistent error response format\n5. Test error logging to ensure sensitive data is not exposed",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Add missing database indexes for common query patterns",
        "description": "Create missing composite indexes for common query patterns to improve database performance and query efficiency.",
        "details": "1. Identify common query patterns from the codebase\n2. Create a migration to add missing indexes\n3. Benchmark query performance before and after\n4. Document the indexes and their purpose\n\nPseudo-code implementation:\n```typescript\n// src/migrations/1704456790-AddMissingIndexes.ts\nimport { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class AddMissingIndexes1704456790 implements MigrationInterface {\n  name = 'AddMissingIndexes1704456790';\n\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Common query: WHERE date = ? AND traditionId = ? AND readingOffice = ?\n    await queryRunner.query(`\n      CREATE INDEX IF NOT EXISTS \"idx_reading_date_tradition_office\" \n      ON \"reading\" (\"date\", \"tradition_id\", \"reading_office\")\n    `);\n    \n    // Common query: WHERE traditionId = ? AND year = ?\n    await queryRunner.query(`\n      CREATE INDEX IF NOT EXISTS \"idx_tradition_year\" \n      ON \"tradition\" (\"tradition_id\", \"year\")\n    `);\n    \n    // Common query: WHERE date >= ? AND date <= ? AND traditionId = ?\n    await queryRunner.query(`\n      CREATE INDEX IF NOT EXISTS \"idx_reading_date_range_tradition\" \n      ON \"reading\" (\"date\", \"tradition_id\")\n    `);\n    \n    // Common query: WHERE proper = ? AND traditionId = ?\n    await queryRunner.query(`\n      CREATE INDEX IF NOT EXISTS \"idx_reading_proper_tradition\" \n      ON \"reading\" (\"proper\", \"tradition_id\")\n    `);\n    \n    // Remove redundant indexes\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_tradition_name_unique\"`);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    // Remove added indexes\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_reading_proper_tradition\"`);\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_reading_date_range_tradition\"`);\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_tradition_year\"`);\n    await queryRunner.query(`DROP INDEX IF EXISTS \"idx_reading_date_tradition_office\"`);\n    \n    // Restore removed indexes\n    await queryRunner.query(`\n      CREATE UNIQUE INDEX IF NOT EXISTS \"idx_tradition_name_unique\" \n      ON \"tradition\" (\"name\")\n    `);\n  }\n}\n```",
        "testStrategy": "1. Benchmark query performance before and after index creation\n2. Test with large datasets to verify index effectiveness\n3. Verify indexes are being used with EXPLAIN ANALYZE\n4. Test index creation and removal (migration up/down)\n5. Document index usage patterns",
        "priority": "medium",
        "dependencies": [
          50
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Standardize response formats across all endpoints",
        "description": "Create a consistent response envelope format for all API endpoints to improve client integration and developer experience.",
        "details": "1. Define a standard response format for all endpoints\n2. Create response formatter utilities\n3. Update all controllers to use the standard format\n4. Document the response format in Swagger\n\nPseudo-code implementation:\n```typescript\n// src/utils/response-formatter.ts\nexport interface StandardResponse<T> {\n  data: T;\n  timestamp: string;\n  pagination?: {\n    total: number;\n    page: number;\n    limit: number;\n    hasMore: boolean;\n  };\n}\n\nexport function formatResponse<T>(data: T, pagination?: { total: number; page: number; limit: number }): StandardResponse<T> {\n  const response: StandardResponse<T> = {\n    data,\n    timestamp: new Date().toISOString()\n  };\n  \n  if (pagination) {\n    response.pagination = {\n      ...pagination,\n      hasMore: pagination.page * pagination.limit < pagination.total\n    };\n  }\n  \n  return response;\n}\n\n// In controllers\nimport { formatResponse } from '../utils/response-formatter';\n\nexport class ReadingsController {\n  async getToday(req: Request, res: Response) {\n    try {\n      const readings = await this.readingsService.getReadingsForToday();\n      return res.json(formatResponse(readings));\n    } catch (error) {\n      next(error);\n    }\n  }\n  \n  async getByDateRange(req: Request, res: Response) {\n    try {\n      const { startDate, endDate } = req.query;\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 10;\n      \n      const { readings, total } = await this.readingsService.getByDateRange(\n        startDate as string,\n        endDate as string,\n        page,\n        limit\n      );\n      \n      return res.json(formatResponse(readings, { total, page, limit }));\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\n// Update admin routes to use the same format\nrouter.post('/run-migrations', adminAuth, async (req, res) => {\n  try {\n    const result = await runMigrations();\n    return res.json(formatResponse({ success: true, message: 'Migrations completed', results: result }));\n  } catch (error) {\n    next(error);\n  }\n});\n```",
        "testStrategy": "1. Unit test the response formatter utility\n2. Test with different data types and pagination options\n3. Integration test all endpoints to verify consistent response format\n4. Verify Swagger documentation matches actual response format\n5. Test error responses follow the same format",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-14T17:36:14.216Z",
      "updated": "2026-01-03T15:54:53.814Z",
      "description": "Tasks for master context"
    }
  },
  "project-overhaul": {
    "tasks": [
      {
        "id": 1,
        "title": "Remove default admin key and implement proper environment validation",
        "description": "Replace the default admin key with proper environment variable validation that fails on startup if the ADMIN_KEY is not set.",
        "details": "Modify the admin routes file to remove the default fallback value for ADMIN_KEY and implement proper validation:\n\n```typescript\n// In src/routes/admin.routes.ts\n// Replace:\nconst ADMIN_KEY = process.env.ADMIN_KEY || 'default-admin-key-change-me';\n\n// With:\nconst ADMIN_KEY = process.env.ADMIN_KEY;\nif (!ADMIN_KEY) {\n  throw new Error('ADMIN_KEY environment variable is required');\n}\n\n// Also update the application startup in src/index.ts to handle this error gracefully\nprocess.on('uncaughtException', (error) => {\n  if (error.message.includes('ADMIN_KEY environment variable is required')) {\n    console.error('FATAL: Missing required environment variable ADMIN_KEY');\n    process.exit(1);\n  }\n  // Handle other uncaught exceptions\n});\n```\n\nEnsure that deployment documentation is updated to reflect this required environment variable.",
        "testStrategy": "1. Unit test: Verify that the application throws an error when ADMIN_KEY is not set\n2. Integration test: Verify that the application exits with a non-zero status code when ADMIN_KEY is missing\n3. Manual test: Attempt to start the application without setting ADMIN_KEY and verify it fails with a clear error message",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove default fallback value from ADMIN_KEY",
            "description": "Modify admin.routes.ts to throw error if ADMIN_KEY env var is not set instead of using default value",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Add startup validation for required environment variables",
            "description": "Create validation in index.ts or config to check all required env vars before server starts",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "Remove default database credentials",
            "description": "Remove default postgres/password fallbacks from database.config.ts",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Enable SSL certificate validation for database connections",
        "description": "Fix the critical security vulnerability by enabling proper SSL certificate validation for database connections.",
        "details": "Modify the database configuration to properly validate SSL certificates:\n\n```typescript\n// In src/config/database.config.ts\n// Replace:\nssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false,\n\n// With:\nssl: process.env.DB_SSL === 'true' ? \n  { \n    rejectUnauthorized: true,\n    ca: process.env.DB_CA_CERT ? fs.readFileSync(process.env.DB_CA_CERT) : undefined \n  } : \n  false,\n```\n\nAdd the necessary imports at the top of the file:\n```typescript\nimport * as fs from 'fs';\n```\n\nUpdate deployment documentation to include instructions for providing the CA certificate file path via the DB_CA_CERT environment variable when DB_SSL is enabled.",
        "testStrategy": "1. Unit test: Verify that the SSL configuration is correctly set based on environment variables\n2. Integration test: Set up a test database with SSL enabled and verify connection succeeds with proper certificates\n3. Security test: Attempt to connect with an invalid certificate and verify connection is rejected",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update SSL config to validate certificates",
            "description": "Change rejectUnauthorized from false to true in database.config.ts",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "Configure CA certificate for production database",
            "description": "Set up proper CA certificate handling for DigitalOcean managed database",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Move admin key to Authorization header with constant-time comparison",
        "description": "Improve security by moving the admin key from request body to Authorization header and implement constant-time comparison to prevent timing attacks.",
        "details": "Modify the admin routes to use Authorization header instead of request body:\n\n```typescript\n// In src/routes/admin.routes.ts\n// Import crypto for constant-time comparison\nimport * as crypto from 'crypto';\n\n// Replace the key verification middleware\nconst verifyAdminKey = (req: Request, res: Response, next: NextFunction) => {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Unauthorized: Missing or invalid Authorization header' });\n  }\n  \n  const providedKey = authHeader.substring(7); // Remove 'Bearer ' prefix\n  \n  // Use constant-time comparison to prevent timing attacks\n  if (!crypto.timingSafeEqual(Buffer.from(providedKey), Buffer.from(ADMIN_KEY))) {\n    return res.status(403).json({ error: 'Forbidden: Invalid admin key' });\n  }\n  \n  next();\n};\n\n// Update all admin routes to use this middleware\n```\n\nUpdate any client code or documentation to reflect this change in authentication method.",
        "testStrategy": "1. Unit test: Verify that the middleware correctly validates the Authorization header\n2. Integration test: Test admin endpoints with valid and invalid Authorization headers\n3. Security test: Verify that timing attacks are mitigated by using constant-time comparison",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Move admin key from request body to Authorization header",
            "description": "Update admin.routes.ts to read key from Authorization header instead of req.body",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "Implement constant-time comparison for admin key",
            "description": "Use crypto.timingSafeEqual to prevent timing attacks on admin key validation",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "Redact sensitive data from error logs",
            "description": "Update error-handler.ts to filter admin keys and credentials before logging",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement authentication middleware for all API endpoints",
        "description": "Add authentication middleware to all public API endpoints as required by the project specifications.",
        "details": "Create an authentication middleware and apply it to all non-health check routes:\n\n```typescript\n// Create src/middleware/auth.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport * as crypto from 'crypto';\n\nconst API_KEY = process.env.API_KEY;\nif (!API_KEY) {\n  throw new Error('API_KEY environment variable is required');\n}\n\nexport const authenticateApiRequest = (req: Request, res: Response, next: NextFunction) => {\n  const apiKey = req.headers['x-api-key'];\n  \n  if (!apiKey) {\n    return res.status(401).json({ \n      error: { \n        message: 'Authentication required', \n        statusCode: 401,\n        timestamp: new Date().toISOString()\n      } \n    });\n  }\n  \n  // Use constant-time comparison\n  if (!crypto.timingSafeEqual(Buffer.from(apiKey.toString()), Buffer.from(API_KEY))) {\n    return res.status(403).json({ \n      error: { \n        message: 'Invalid API key', \n        statusCode: 403,\n        timestamp: new Date().toISOString()\n      } \n    });\n  }\n  \n  next();\n};\n```\n\nApply this middleware to all route files:\n\n```typescript\n// In src/routes/readings.routes.ts, traditions.routes.ts, calendar.routes.ts\nimport { authenticateApiRequest } from '../middleware/auth.middleware';\n\n// Apply to all routes except health checks\nrouter.use(authenticateApiRequest);\n```\n\nUpdate the application documentation to reflect the authentication requirements.",
        "testStrategy": "1. Unit test: Verify that the middleware correctly validates the API key\n2. Integration test: Test all endpoints with valid and invalid API keys\n3. E2E test: Verify that health check endpoints remain accessible without authentication\n4. Documentation test: Ensure API documentation reflects authentication requirements",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API key authentication middleware",
            "description": "Implement middleware that validates API keys from Authorization header",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "Apply auth middleware to readings routes",
            "description": "Add authentication middleware to all /api/v1/readings endpoints",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "Apply auth middleware to traditions routes",
            "description": "Add authentication middleware to all /api/v1/traditions endpoints",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "Apply auth middleware to calendar routes",
            "description": "Add authentication middleware to all /api/v1/calendar endpoints",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Replace execSync with job queue for admin operations",
        "description": "Replace the synchronous shell command execution in admin routes with an asynchronous job queue to prevent command injection and blocking the event loop.",
        "details": "Install and implement a job queue system (Bull with Redis):\n\n```bash\nnpm install bull redis @types/bull\n```\n\nCreate a job queue service:\n\n```typescript\n// Create src/services/job-queue.service.ts\nimport Queue from 'bull';\nimport { TypeormMigrationRunner } from '../utils/typeorm-migration-runner';\nimport { DataImporter } from '../utils/data-importer';\n\nexport class JobQueueService {\n  private migrationQueue: Queue.Queue;\n  private importQueue: Queue.Queue;\n  \n  constructor() {\n    const redisConfig = {\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379')\n    };\n    \n    this.migrationQueue = new Queue('database-migrations', { redis: redisConfig });\n    this.importQueue = new Queue('data-imports', { redis: redisConfig });\n    \n    this.setupProcessors();\n  }\n  \n  private setupProcessors() {\n    this.migrationQueue.process(async (job) => {\n      const migrationRunner = new TypeormMigrationRunner();\n      return await migrationRunner.runMigrations();\n    });\n    \n    this.importQueue.process(async (job) => {\n      const importer = new DataImporter();\n      return await importer.importRclWithDates();\n    });\n  }\n  \n  public async queueMigration() {\n    return this.migrationQueue.add({}, { attempts: 3 });\n  }\n  \n  public async queueImport() {\n    return this.importQueue.add({}, { attempts: 3 });\n  }\n}\n```\n\nCreate the utility classes to handle the operations programmatically:\n\n```typescript\n// Create src/utils/typeorm-migration-runner.ts\nimport { DataSource } from 'typeorm';\nimport { DatabaseService } from '../services/database.service';\n\nexport class TypeormMigrationRunner {\n  async runMigrations() {\n    const dataSource = await DatabaseService.getDataSource();\n    const migrations = await dataSource.runMigrations();\n    return { success: true, migrations };\n  }\n}\n\n// Create src/utils/data-importer.ts\n// Implement the programmatic version of the import script\n```\n\nUpdate the admin routes to use the job queue:\n\n```typescript\n// In src/routes/admin.routes.ts\nimport { JobQueueService } from '../services/job-queue.service';\n\nconst jobQueueService = new JobQueueService();\n\n// Replace execSync calls with job queue\nrouter.post('/run-migrations', verifyAdminKey, async (req, res) => {\n  try {\n    const job = await jobQueueService.queueMigration();\n    res.json({ success: true, message: 'Migration job queued', jobId: job.id });\n  } catch (error) {\n    res.status(500).json({ error: `Failed to queue migration: ${error.message}` });\n  }\n});\n\nrouter.post('/import-rcl', verifyAdminKey, async (req, res) => {\n  try {\n    const job = await jobQueueService.queueImport();\n    res.json({ success: true, message: 'Import job queued', jobId: job.id });\n  } catch (error) {\n    res.status(500).json({ error: `Failed to queue import: ${error.message}` });\n  }\n});\n```\n\nAdd a new endpoint to check job status:\n\n```typescript\nrouter.get('/job/:id', verifyAdminKey, async (req, res) => {\n  try {\n    const jobId = req.params.id;\n    const migrationJob = await jobQueueService.migrationQueue.getJob(jobId);\n    const importJob = await jobQueueService.importQueue.getJob(jobId);\n    const job = migrationJob || importJob;\n    \n    if (!job) {\n      return res.status(404).json({ error: 'Job not found' });\n    }\n    \n    const state = await job.getState();\n    const result = job.returnvalue;\n    \n    res.json({ jobId, state, result });\n  } catch (error) {\n    res.status(500).json({ error: `Failed to get job status: ${error.message}` });\n  }\n});\n```",
        "testStrategy": "1. Unit test: Verify that the job queue service correctly queues jobs\n2. Integration test: Test the job queue with mock operations\n3. E2E test: Verify that admin endpoints correctly queue jobs and return job IDs\n4. Security test: Verify that command injection is no longer possible",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure BullMQ job queue",
            "description": "Set up BullMQ with Redis for background job processing",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "Replace execSync migration call with job",
            "description": "Convert migration:run from execSync to BullMQ job",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Create database schema sync migration",
        "description": "Create a comprehensive migration to align the database schema with entity definitions, fixing the critical issue of missing columns and type mismatches.",
        "details": "Create a new migration that addresses all schema drift issues:\n\n```typescript\n// Create src/migrations/1704456789-SchemaSyncFix.ts\nimport { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class SchemaSyncFix1704456789 implements MigrationInterface {\n  name = 'SchemaSyncFix1704456789';\n\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Check if tradition_id column exists in special_day table\n    const specialDayColumns = await queryRunner.query(\n      `SELECT column_name FROM information_schema.columns WHERE table_name = 'special_day' AND column_name = 'tradition_id'`\n    );\n    \n    if (specialDayColumns.length === 0) {\n      // Add missing tradition_id column\n      await queryRunner.query(\n        `ALTER TABLE \"special_day\" ADD \"tradition_id\" integer`\n      );\n      \n      // Add foreign key constraint\n      await queryRunner.query(\n        `ALTER TABLE \"special_day\" ADD CONSTRAINT \"FK_special_day_tradition\" FOREIGN KEY (\"tradition_id\") REFERENCES \"tradition\"(\"id\") ON DELETE CASCADE`\n      );\n    }\n    \n    // Fix rank column type if needed\n    await queryRunner.query(\n      `ALTER TABLE \"special_day\" ALTER COLUMN \"rank\" TYPE varchar USING rank::varchar`\n    );\n    \n    // Fix reading_office column type if needed\n    await queryRunner.query(\n      `ALTER TABLE \"reading\" ALTER COLUMN \"reading_office\" TYPE varchar USING reading_office::varchar`\n    );\n    \n    // Add missing indexes\n    await queryRunner.query(\n      `CREATE INDEX IF NOT EXISTS \"idx_reading_date_tradition_office\" ON \"reading\" (\"date\", \"tradition_id\", \"reading_office\")`\n    );\n    \n    await queryRunner.query(\n      `CREATE INDEX IF NOT EXISTS \"idx_tradition_year\" ON \"reading\" (\"tradition_id\", \"year\")`\n    );\n    \n    // Remove redundant indexes\n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_tradition_name_unique\"`\n    );\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    // Revert index changes\n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_reading_date_tradition_office\"`\n    );\n    \n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_tradition_year\"`\n    );\n    \n    await queryRunner.query(\n      `CREATE UNIQUE INDEX IF NOT EXISTS \"idx_tradition_name_unique\" ON \"tradition\" (\"name\")`\n    );\n    \n    // Note: We don't revert the column additions or type changes as that could cause data loss\n    // In a real down migration, you would need to carefully handle this\n  }\n}\n```\n\nCreate a script to verify schema alignment:\n\n```typescript\n// Create src/scripts/verify-schema-alignment.ts\nimport { DatabaseService } from '../services/database.service';\n\nasync function verifySchemaAlignment() {\n  const dataSource = await DatabaseService.getDataSource();\n  const queryRunner = dataSource.createQueryRunner();\n  \n  try {\n    // Check for all known schema drift issues\n    const issues = [];\n    \n    // Check special_day.tradition_id\n    const specialDayColumns = await queryRunner.query(\n      `SELECT column_name FROM information_schema.columns WHERE table_name = 'special_day' AND column_name = 'tradition_id'`\n    );\n    \n    if (specialDayColumns.length === 0) {\n      issues.push('Missing column: special_day.tradition_id');\n    }\n    \n    // Check other columns and types...\n    \n    if (issues.length === 0) {\n      console.log('✅ Schema is aligned with entity definitions');\n    } else {\n      console.error('❌ Schema drift detected:');\n      issues.forEach(issue => console.error(`- ${issue}`));\n    }\n  } finally {\n    await queryRunner.release();\n  }\n}\n\nverifySchemaAlignment().catch(console.error);\n```\n\nAdd a new admin endpoint to run the verification:\n\n```typescript\n// In src/routes/admin.routes.ts\nrouter.get('/verify-schema', verifyAdminKey, async (req, res) => {\n  try {\n    const dataSource = await DatabaseService.getDataSource();\n    const queryRunner = dataSource.createQueryRunner();\n    \n    try {\n      // Perform schema verification checks\n      const issues = [];\n      \n      // Check special_day.tradition_id\n      const specialDayColumns = await queryRunner.query(\n        `SELECT column_name FROM information_schema.columns WHERE table_name = 'special_day' AND column_name = 'tradition_id'`\n      );\n      \n      if (specialDayColumns.length === 0) {\n        issues.push('Missing column: special_day.tradition_id');\n      }\n      \n      // Add more checks...\n      \n      res.json({ success: true, schemaAligned: issues.length === 0, issues });\n    } finally {\n      await queryRunner.release();\n    }\n  } catch (error) {\n    res.status(500).json({ error: `Failed to verify schema: ${error.message}` });\n  }\n});\n```",
        "testStrategy": "1. Unit test: Verify that the migration correctly identifies and fixes schema issues\n2. Integration test: Run the migration on a test database and verify the schema matches entity definitions\n3. Verification test: Run the schema verification script before and after migration to confirm fixes\n4. Rollback test: Test the down migration to ensure it properly reverts changes",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement dependency injection container",
        "description": "Implement a dependency injection container to reduce tight coupling, improve testability, and enable proper lifecycle management of services.",
        "details": "Install the tsyringe DI container:\n\n```bash\nnpm install tsyringe reflect-metadata\n```\n\nAdd reflect-metadata import to the entry point:\n\n```typescript\n// In src/index.ts at the top\nimport 'reflect-metadata';\n```\n\nCreate interfaces for services:\n\n```typescript\n// Create src/interfaces/services/readings-service.interface.ts\nexport interface IReadingsService {\n  findReadingsByDate(date: string, traditionId?: number): Promise<any>;\n  getToday(traditionId?: number): Promise<any>;\n  // Add other methods...\n}\n\n// Create similar interfaces for other services\n```\n\nUpdate services to implement interfaces and use DI:\n\n```typescript\n// In src/services/readings.service.ts\nimport { injectable, inject } from 'tsyringe';\nimport { IReadingsService } from '../interfaces/services/readings-service.interface';\nimport { ITraditionsService } from '../interfaces/services/traditions-service.interface';\n\n@injectable()\nexport class ReadingsService implements IReadingsService {\n  constructor(\n    @inject('TraditionsService') private traditionsService: ITraditionsService,\n    @inject('DatabaseService') private databaseService: DatabaseService\n  ) {}\n  \n  // Implement methods using injected dependencies\n}\n```\n\nUpdate the database service to be injectable:\n\n```typescript\n// In src/services/database.service.ts\nimport { singleton } from 'tsyringe';\n\n@singleton()\nexport class DatabaseService {\n  private dataSource: DataSource;\n  \n  constructor() {\n    // Initialize dataSource\n  }\n  \n  public async getDataSource(): Promise<DataSource> {\n    if (!this.dataSource || !this.dataSource.isInitialized) {\n      // Initialize dataSource\n    }\n    return this.dataSource;\n  }\n}\n```\n\nRegister services in a container configuration:\n\n```typescript\n// Create src/config/container.ts\nimport { container } from 'tsyringe';\nimport { DatabaseService } from '../services/database.service';\nimport { ReadingsService } from '../services/readings.service';\nimport { TraditionsService } from '../services/traditions.service';\nimport { CalendarService } from '../services/calendar.service';\n\nexport function configureContainer() {\n  // Register services\n  container.registerSingleton('DatabaseService', DatabaseService);\n  container.registerSingleton('ReadingsService', ReadingsService);\n  container.registerSingleton('TraditionsService', TraditionsService);\n  container.registerSingleton('CalendarService', CalendarService);\n  \n  return container;\n}\n```\n\nUpdate controllers to use DI:\n\n```typescript\n// In src/controllers/readings.controller.ts\nimport { injectable, inject } from 'tsyringe';\nimport { IReadingsService } from '../interfaces/services/readings-service.interface';\n\n@injectable()\nexport class ReadingsController {\n  constructor(\n    @inject('ReadingsService') private readingsService: IReadingsService\n  ) {}\n  \n  // Controller methods using injected service\n}\n```\n\nUpdate route files to use the container:\n\n```typescript\n// In src/routes/readings.routes.ts\nimport { container } from 'tsyringe';\nimport { ReadingsController } from '../controllers/readings.controller';\n\nconst router = express.Router();\nconst readingsController = container.resolve(ReadingsController);\n\nrouter.get('/today', (req, res) => readingsController.getToday(req, res));\n// Other routes...\n\nexport default router;\n```\n\nUpdate app.ts to configure the container:\n\n```typescript\n// In src/app.ts\nimport { configureContainer } from './config/container';\n\n// Configure DI container\nconfigureContainer();\n```",
        "testStrategy": "1. Unit test: Verify that services can be resolved from the container\n2. Integration test: Test that controllers correctly use injected services\n3. Mocking test: Verify that services can be easily mocked for testing\n4. Lifecycle test: Verify that singleton services maintain state correctly",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Fix error handling in services to prevent silent failures",
        "description": "Update service methods to properly propagate errors instead of silently returning null or empty arrays, allowing controllers to decide how to handle errors.",
        "details": "Refactor error handling in services to properly propagate errors:\n\n```typescript\n// In src/services/readings.service.ts\n\n// Replace patterns like this:\nasync findReadingsByDate(date: string, traditionId?: number): Promise<any> {\n  try {\n    // ... implementation ...\n  } catch (error) {\n    logger.error(`Error fetching readings for date ${date}:`, error);\n    return null;  // Silent failure\n  }\n}\n\n// With proper error propagation:\nasync findReadingsByDate(date: string, traditionId?: number): Promise<any> {\n  try {\n    // ... implementation ...\n  } catch (error) {\n    logger.error(`Error fetching readings for date ${date}:`, error);\n    // Create a custom error with context\n    throw new ServiceError(\n      'Failed to fetch readings', \n      { date, traditionId, originalError: error }\n    );\n  }\n}\n```\n\nCreate a custom error class:\n\n```typescript\n// Create src/utils/errors.ts\nexport class ServiceError extends Error {\n  public readonly context: any;\n  \n  constructor(message: string, context: any = {}) {\n    super(message);\n    this.name = 'ServiceError';\n    this.context = context;\n  }\n}\n```\n\nUpdate controllers to handle these errors properly:\n\n```typescript\n// In src/controllers/readings.controller.ts\nimport { ServiceError } from '../utils/errors';\n\nasync getReadingsByDate(req: Request, res: Response): Promise<void> {\n  try {\n    const { date } = req.params;\n    const { traditionId } = req.query;\n    \n    const readings = await this.readingsService.findReadingsByDate(\n      date, \n      traditionId ? parseInt(traditionId as string) : undefined\n    );\n    \n    res.json({\n      data: readings,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    if (error instanceof ServiceError) {\n      // Log with request context\n      logger.error(`Service error in getReadingsByDate: ${error.message}`, {\n        requestId: req.id,\n        path: req.path,\n        params: req.params,\n        query: req.query,\n        context: error.context\n      });\n      \n      res.status(500).json({\n        error: {\n          message: 'Failed to retrieve readings',\n          statusCode: 500,\n          timestamp: new Date().toISOString()\n        }\n      });\n    } else {\n      // Unexpected error\n      logger.error(`Unexpected error in getReadingsByDate: ${error.message}`, error);\n      res.status(500).json({\n        error: {\n          message: 'An unexpected error occurred',\n          statusCode: 500,\n          timestamp: new Date().toISOString()\n        }\n      });\n    }\n  }\n}\n```\n\nUpdate the error handler middleware to handle these custom errors:\n\n```typescript\n// In src/middleware/error-handler.ts\nimport { ServiceError } from '../utils/errors';\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {\n  if (err instanceof ServiceError) {\n    // Handle service errors\n    logger.error(`Service error: ${err.message}`, {\n      requestId: req.id,\n      path: req.path,\n      context: err.context\n    });\n    \n    return res.status(500).json({\n      error: {\n        message: err.message,\n        statusCode: 500,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n  \n  // Handle other error types...\n};\n```",
        "testStrategy": "1. Unit test: Verify that service methods throw appropriate errors\n2. Integration test: Test error propagation from services to controllers\n3. E2E test: Verify that API endpoints return proper error responses\n4. Logging test: Verify that errors are logged with appropriate context",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Standardize API response formats",
        "description": "Create a consistent response format for all API endpoints to improve client integration and maintainability.",
        "details": "Create a response formatter utility:\n\n```typescript\n// Create src/utils/response-formatter.ts\nexport interface StandardResponse<T> {\n  data: T;\n  timestamp: string;\n  pagination?: {\n    total: number;\n    page: number;\n    limit: number;\n  };\n}\n\nexport interface ErrorResponse {\n  error: {\n    message: string;\n    statusCode: number;\n    timestamp: string;\n    details?: any;\n  };\n}\n\nexport class ResponseFormatter {\n  static success<T>(data: T, pagination?: { total: number; page: number; limit: number; }): StandardResponse<T> {\n    return {\n      data,\n      timestamp: new Date().toISOString(),\n      pagination\n    };\n  }\n  \n  static error(message: string, statusCode: number, details?: any): ErrorResponse {\n    return {\n      error: {\n        message,\n        statusCode,\n        timestamp: new Date().toISOString(),\n        details\n      }\n    };\n  }\n}\n```\n\nUpdate controllers to use the formatter:\n\n```typescript\n// In src/controllers/readings.controller.ts\nimport { ResponseFormatter } from '../utils/response-formatter';\n\nasync getReadingsByDate(req: Request, res: Response): Promise<void> {\n  try {\n    const { date } = req.params;\n    const { traditionId } = req.query;\n    \n    const readings = await this.readingsService.findReadingsByDate(\n      date, \n      traditionId ? parseInt(traditionId as string) : undefined\n    );\n    \n    res.json(ResponseFormatter.success(readings));\n  } catch (error) {\n    // Handle error...\n    res.status(500).json(ResponseFormatter.error('Failed to retrieve readings', 500));\n  }\n}\n\nasync getReadingsByDateRange(req: Request, res: Response): Promise<void> {\n  try {\n    const { startDate, endDate } = req.params;\n    const { traditionId, page = '1', limit = '10' } = req.query;\n    \n    const pageNum = parseInt(page as string);\n    const limitNum = parseInt(limit as string);\n    \n    const { readings, total } = await this.readingsService.getByDateRange(\n      startDate,\n      endDate,\n      traditionId ? parseInt(traditionId as string) : undefined,\n      pageNum,\n      limitNum\n    );\n    \n    res.json(ResponseFormatter.success(readings, { total, page: pageNum, limit: limitNum }));\n  } catch (error) {\n    // Handle error...\n  }\n}\n```\n\nUpdate admin routes to use the same format:\n\n```typescript\n// In src/routes/admin.routes.ts\nimport { ResponseFormatter } from '../utils/response-formatter';\n\nrouter.post('/run-migrations', verifyAdminKey, async (req, res) => {\n  try {\n    // Implementation...\n    res.json(ResponseFormatter.success({ message: 'Migrations completed successfully', results }));\n  } catch (error) {\n    res.status(500).json(ResponseFormatter.error(`Failed to run migrations: ${error.message}`, 500));\n  }\n});\n```\n\nUpdate error handler middleware to use the formatter:\n\n```typescript\n// In src/middleware/error-handler.ts\nimport { ResponseFormatter } from '../utils/response-formatter';\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {\n  // Handle different error types...\n  \n  // Default error response\n  const statusCode = 500;\n  res.status(statusCode).json(ResponseFormatter.error(\n    'An unexpected error occurred',\n    statusCode\n  ));\n};\n```\n\nUpdate the OpenAPI/Swagger documentation to reflect the standardized response format:\n\n```typescript\n// In src/config/swagger.ts\nconst responseSchemas = {\n  StandardResponse: {\n    type: 'object',\n    properties: {\n      data: {\n        type: 'object',\n        description: 'Response data'\n      },\n      timestamp: {\n        type: 'string',\n        format: 'date-time',\n        description: 'Response timestamp'\n      },\n      pagination: {\n        type: 'object',\n        properties: {\n          total: { type: 'integer' },\n          page: { type: 'integer' },\n          limit: { type: 'integer' }\n        },\n        required: ['total', 'page', 'limit']\n      }\n    },\n    required: ['data', 'timestamp']\n  },\n  ErrorResponse: {\n    type: 'object',\n    properties: {\n      error: {\n        type: 'object',\n        properties: {\n          message: { type: 'string' },\n          statusCode: { type: 'integer' },\n          timestamp: { type: 'string', format: 'date-time' },\n          details: { type: 'object' }\n        },\n        required: ['message', 'statusCode', 'timestamp']\n      }\n    },\n    required: ['error']\n  }\n};\n```",
        "testStrategy": "1. Unit test: Verify that the ResponseFormatter correctly formats success and error responses\n2. Integration test: Test that all controllers use the standardized format\n3. API test: Verify that all endpoints return responses in the expected format\n4. Documentation test: Ensure that Swagger documentation reflects the standardized format",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Add missing database indexes for common query patterns",
        "description": "Create missing composite indexes to optimize common query patterns and improve database performance.",
        "details": "Create a new migration to add the missing indexes:\n\n```typescript\n// Create src/migrations/1704456790-AddMissingIndexes.ts\nimport { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class AddMissingIndexes1704456790 implements MigrationInterface {\n  name = 'AddMissingIndexes1704456790';\n\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Add composite index for common reading lookup pattern\n    await queryRunner.query(\n      `CREATE INDEX IF NOT EXISTS \"idx_reading_date_tradition_office\" ON \"reading\" (\"date\", \"tradition_id\", \"reading_office\")`\n    );\n    \n    // Add index for tradition and year lookups\n    await queryRunner.query(\n      `CREATE INDEX IF NOT EXISTS \"idx_reading_tradition_year\" ON \"reading\" (\"tradition_id\", \"year\")`\n    );\n    \n    // Add index for liturgical year lookups\n    await queryRunner.query(\n      `CREATE INDEX IF NOT EXISTS \"idx_reading_liturgical_year\" ON \"reading\" (\"liturgical_year_id\")`\n    );\n    \n    // Add index for special day lookups\n    await queryRunner.query(\n      `CREATE INDEX IF NOT EXISTS \"idx_special_day_date_tradition\" ON \"special_day\" (\"date\", \"tradition_id\")`\n    );\n    \n    // Remove redundant indexes\n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_tradition_name_unique\"`\n    );\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    // Remove added indexes\n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_reading_date_tradition_office\"`\n    );\n    \n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_reading_tradition_year\"`\n    );\n    \n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_reading_liturgical_year\"`\n    );\n    \n    await queryRunner.query(\n      `DROP INDEX IF EXISTS \"idx_special_day_date_tradition\"`\n    );\n    \n    // Restore removed indexes\n    await queryRunner.query(\n      `CREATE UNIQUE INDEX IF NOT EXISTS \"idx_tradition_name_unique\" ON \"tradition\" (\"name\")`\n    );\n  }\n}\n```\n\nCreate a script to analyze query performance:\n\n```typescript\n// Create src/scripts/analyze-query-performance.ts\nimport { DatabaseService } from '../services/database.service';\n\nasync function analyzeQueryPerformance() {\n  const dataSource = await DatabaseService.getDataSource();\n  const queryRunner = dataSource.createQueryRunner();\n  \n  try {\n    // Test common query patterns\n    console.log('Analyzing query performance...');\n    \n    // Test date + tradition + office query\n    console.time('Query 1: date + tradition + office');\n    await queryRunner.query(\n      `EXPLAIN ANALYZE SELECT * FROM reading WHERE date = '2023-01-01' AND tradition_id = 1 AND reading_office = 'morning'`\n    );\n    console.timeEnd('Query 1: date + tradition + office');\n    \n    // Test tradition + year query\n    console.time('Query 2: tradition + year');\n    await queryRunner.query(\n      `EXPLAIN ANALYZE SELECT * FROM reading WHERE tradition_id = 1 AND year = 'A'`\n    );\n    console.timeEnd('Query 2: tradition + year');\n    \n    // Add more query tests...\n    \n  } finally {\n    await queryRunner.release();\n  }\n}\n\nanalyzeQueryPerformance().catch(console.error);\n```\n\nAdd an admin endpoint to run the performance analysis:\n\n```typescript\n// In src/routes/admin.routes.ts\nrouter.get('/analyze-performance', verifyAdminKey, async (req, res) => {\n  try {\n    const dataSource = await DatabaseService.getDataSource();\n    const queryRunner = dataSource.createQueryRunner();\n    \n    try {\n      const results = {};\n      \n      // Test date + tradition + office query\n      const query1 = await queryRunner.query(\n        `EXPLAIN ANALYZE SELECT * FROM reading WHERE date = '2023-01-01' AND tradition_id = 1 AND reading_office = 'morning'`\n      );\n      results.dateAndTraditionQuery = query1;\n      \n      // Add more query tests...\n      \n      res.json(ResponseFormatter.success({ performanceAnalysis: results }));\n    } finally {\n      await queryRunner.release();\n    }\n  } catch (error) {\n    res.status(500).json(ResponseFormatter.error(`Failed to analyze performance: ${error.message}`, 500));\n  }\n});\n```",
        "testStrategy": "1. Performance test: Measure query execution time before and after adding indexes\n2. Integration test: Verify that indexes are correctly created by the migration\n3. Rollback test: Verify that indexes are correctly removed when rolling back the migration\n4. Load test: Verify performance improvement under load with the new indexes",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-03T02:32:32.291Z",
      "updated": "2026-01-03T02:32:32.291Z",
      "description": "Tasks for project-overhaul context"
    }
  }
}