# Lectionary API - Product Requirements Document

## Project Overview

### Product Name
Lectionary API - A comprehensive RESTful API for liturgical calendar data and scripture readings

### Product Vision
To provide a robust, scalable, and developer-friendly API that serves liturgical calendar data and scripture readings across multiple Christian traditions, enabling churches, developers, and worship communities to integrate lectionary data into their applications and services.

### Target Audience
- Church application developers
- Worship planning software creators
- Religious education platforms
- Seminary and theological institutions
- Individual developers building faith-based applications

## Core Features and Requirements

### 1. Database Architecture and Schema Design
- Design PostgreSQL database schema supporting multiple lectionary traditions
- Implement proper indexing for performance optimization
- Support for liturgical years, seasons, special days, and feast days
- Scalable design for handling multiple traditions simultaneously
- Data integrity and referential constraints
- Migration system for schema versioning

### 2. RESTful API Implementation
- Express.js framework with TypeScript support
- Clean architecture with separation of concerns
- Comprehensive middleware stack (authentication, validation, error handling)
- Support for multiple response formats (JSON, XML if needed)
- Proper HTTP status codes and error responses
- Rate limiting and security measures
- API versioning strategy

### 3. Multi-Tradition Lectionary Support
- Revised Common Lectionary (RCL) as primary tradition
- Catholic lectionary support
- Episcopal/Anglican lectionary support
- Lutheran lectionary support
- Extensible framework for additional traditions
- Tradition-specific calendar calculations
- Support for different liturgical year cycles (A, B, C)

### 4. Core API Endpoints
- GET /api/v1/readings/today - Today's readings
- GET /api/v1/readings/{date} - Readings for specific date
- GET /api/v1/readings/range - Readings for date range
- GET /api/v1/calendar/liturgical-year - Current liturgical year info
- GET /api/v1/calendar/season - Current liturgical season
- GET /api/v1/calendar/special-days - Special days and feast days
- GET /api/v1/traditions - Available lectionary traditions
- GET /api/v1/traditions/{tradition}/readings - Tradition-specific readings

### 5. Data Import and Management System
- Automated data import from official lectionary sources
- Data validation and consistency checks
- Support for multiple data formats (CSV, JSON, XML)
- Bulk update capabilities for annual lectionary changes
- Data versioning and rollback capabilities
- Admin API for data management operations

### 6. Search and Query Capabilities
- Full-text search across scripture references
- Search by liturgical season or special day
- Keyword search in reading metadata
- Advanced filtering options (tradition, year, season)
- Search by scripture book, chapter, verse ranges
- Fuzzy search for approximate matches

### 7. Authentication and Authorization
- API key-based authentication for public endpoints
- JWT token authentication for admin functions
- Rate limiting per API key
- Role-based access control (public, admin, super-admin)
- OAuth2 integration for third-party applications
- Secure password hashing and token management

### 8. Caching and Performance
- Redis-based caching for frequently accessed data
- Query result caching with TTL
- Cache invalidation strategies
- Database query optimization
- Response compression
- CDN integration for static assets

### 9. API Documentation and Developer Experience
- OpenAPI 3.0 specification
- Interactive Swagger UI documentation
- Comprehensive API reference with examples
- SDK generation for multiple languages
- Postman collection for testing
- Developer onboarding guide
- Code examples and tutorials

### 10. Testing and Quality Assurance
- Unit tests for all business logic
- Integration tests for API endpoints
- End-to-end testing for critical workflows
- Load testing for performance validation
- Security testing for authentication and authorization
- Automated testing in CI/CD pipeline
- Test coverage reporting

### 11. Monitoring and Logging
- Application performance monitoring
- Error tracking and alerting
- Request/response logging
- Database query performance monitoring
- Security audit logging
- Health check endpoints
- Metrics collection and visualization

### 12. Deployment and Infrastructure
- Docker containerization
- Kubernetes orchestration
- CI/CD pipeline with GitHub Actions
- Production deployment on cloud platform
- Database backup and recovery
- Load balancing and high availability
- SSL/TLS encryption
- Environment-specific configurations

## Technical Specifications

### Technology Stack
- **Backend**: Node.js, Express.js, TypeScript
- **Database**: PostgreSQL with proper indexing
- **Caching**: Redis for session and query caching
- **Authentication**: JWT tokens, OAuth2
- **Testing**: Jest, Supertest, Postman
- **Documentation**: OpenAPI 3.0, Swagger UI
- **Deployment**: Docker, Kubernetes, GitHub Actions
- **Monitoring**: Application monitoring tools

### Performance Requirements
- API response time: < 200ms for 95th percentile
- Database query response: < 100ms for standard queries
- Support for 1000+ concurrent users
- 99.9% uptime availability
- Horizontal scaling capability
- Efficient memory usage and garbage collection

### Security Requirements
- HTTPS/TLS encryption for all communications
- SQL injection prevention
- XSS protection
- CSRF protection
- Rate limiting to prevent abuse
- Input validation and sanitization
- Secure password storage with bcrypt
- Regular security audits and updates

### Data Requirements
- Complete RCL data for all three years (A, B, C)
- Historical data for past 5 years
- Future projections for next 5 years
- Support for multiple Bible translations
- Metadata for special days and feast days
- Liturgical color information
- Multi-language support for internationalization

## Success Metrics

### Technical Metrics
- API response time consistently under 200ms
- Test coverage above 90%
- Zero critical security vulnerabilities
- Database query performance optimization
- Successful deployment and scaling

### Business Metrics
- Developer adoption and API usage growth
- Positive feedback from developer community
- Successful integration with client applications
- Documentation completeness and clarity
- Community engagement and contributions

## Project Phases

### Phase 1: Foundation
- Project setup and infrastructure
- Database schema design and implementation
- Basic Express.js API framework
- Core authentication system
- Initial testing framework

### Phase 2: Core API Development
- Implement basic reading endpoints
- RCL data import and integration
- Basic search and query capabilities
- API documentation and testing
- Performance optimization

### Phase 3: Advanced Features
- Multi-tradition support
- Advanced search capabilities
- Caching implementation
- Admin API development
- Enhanced security features

### Phase 4: Production Deployment
- Production infrastructure setup
- Monitoring and logging implementation
- Performance testing and optimization
- Security audit and hardening
- Documentation finalization

### Phase 5: Enhancement and Scaling
- Additional lectionary traditions
- Advanced developer tools
- Community features
- Internationalization support
- Continuous improvement based on feedback

## Risk Assessment

### Technical Risks
- Database performance with large datasets
- Complex liturgical calendar calculations
- Multi-tradition data consistency
- API versioning and backward compatibility
- Security vulnerabilities and data breaches

### Mitigation Strategies
- Comprehensive testing and validation
- Regular security audits and updates
- Proper database indexing and optimization
- Clear API versioning strategy
- Robust error handling and logging

## Resource Requirements

### Development Team
- Lead developer/architect
- Backend developers (2-3)
- Database specialist
- DevOps engineer
- QA/Testing specialist
- Technical writer for documentation

### Timeline
- Phase 1: 4-6 weeks
- Phase 2: 6-8 weeks
- Phase 3: 4-6 weeks
- Phase 4: 2-4 weeks
- Phase 5: Ongoing

### Budget Considerations
- Development resources
- Cloud infrastructure costs
- Third-party service integrations
- Security audit and compliance
- Ongoing maintenance and support

## CRITICAL: Immediate Codebase Stabilization Requirements

**URGENT PRIORITY**: The current codebase is in a critical state and is NOT production-ready. The following tasks must be completed immediately before any further development:

### Critical Issues Identified
- 50+ TypeScript compilation errors preventing development
- Broken ESLint configuration blocking code quality enforcement
- Failing tests with incorrect API assumptions
- Missing or incomplete pre-commit hooks
- Zero test coverage for critical functionality
- Type safety violations throughout the codebase

### Phase 0: Emergency Stabilization (Must Complete First)

#### 1. Pre-commit Hooks Implementation
- Set up Husky pre-commit hooks to run TypeScript checking, linting, testing, and build verification
- Ensure no broken code can be committed to repository
- Configure lint-staged for efficient pre-commit validation

#### 2. TypeScript Error Resolution
- Fix all compilation errors in middleware files (health-checks.ts, observability.ts, rate-limiter.ts)
- Resolve type safety issues in models and database entities
- Fix import/export issues and module resolution problems
- Implement proper error handling with typed error objects

#### 3. ESLint Configuration Repair
- Fix broken ESLint configuration preventing linting
- Ensure TypeScript ESLint rules are properly configured
- Fix all linting errors throughout codebase

#### 4. Test Infrastructure Overhaul
- Fix failing integration tests in tests/integration/api.test.ts
- Write comprehensive unit tests for all controllers
- Implement service layer tests for database operations
- Create middleware tests for authentication, rate limiting, observability
- Establish test utilities and fixtures

#### 5. Database and Model Testing
- Test all TypeORM entities and relationships
- Validate migration scripts and seeding processes
- Test entity associations and constraints
- Implement database connection error handling tests

#### 6. API Validation and Testing
- Test all REST endpoints with proper request/response validation
- Verify error handling for invalid inputs
- Test authentication and authorization flows
- Validate API documentation matches implementation

#### 7. Build and Deployment Validation
- Ensure Docker build process works correctly
- Validate environment configuration handling
- Test logging, monitoring, and observability features
- Create deployment validation script

### Acceptance Criteria for Stabilization
- `npm run typecheck` must pass with zero errors
- `npm run lint` must pass with zero errors
- `npm test` must pass all tests with >80% coverage
- `npm run build` must complete successfully
- Pre-commit hooks must prevent broken code commits
- All API endpoints must have working tests
- Database operations must be fully tested and validated

### Risk if Not Completed
**CRITICAL**: Without this stabilization work, the codebase will remain in a broken state, making further development impossible and risking production failures.

## Conclusion

The Lectionary API represents a comprehensive solution for liturgical calendar and scripture reading data. However, immediate attention must be focused on critical codebase stabilization before proceeding with feature development. By prioritizing code quality, testing, and validation infrastructure, this API will serve as a valuable resource for the religious software development community. The phased approach ensures systematic development while maintaining quality and security standards throughout the project lifecycle.